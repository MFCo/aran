window.masters = {};
window.masters.Empty = "\n// This master does absolutely nothing! *yay* //\n";
window.masters.Lazy = "\nfunction delay (fct) {\n  fct.__thunk__ = true\n  return fct\n}\n\nfunction force (val) {\n  if (val && val.__thunk__) { return val.__cached__ || (val.__cached__=val()) }\n  return val\n}\n\nwindow.delay = delay\nwindow.force = force\nwindow.ispromise = function (val) { return Boolean(val && val.__thunk__) }\n\nexports.traps = {\n  function: function (x) {\n    x.__instrumented__ = true\n    return x\n  },\n  booleanize: function (x) { return force(x) },\n  stringify: function (x) { return force(x) },\n  unary: function (op, x) { return eval(op+\" force(x)\") },\n  binary: function (op, x1, x2) { return eval(\"force(x1) \"+op+\" force(x2)\") },\n  apply: function (f, o, xs) {\n    f = force(f)\n    if (f.__instrumented__) { return f.apply(o, xs) }\n    return f.apply(force(o), xs.map(force))\n  },\n  new: function (f, xs) {\n    f = force(f)\n    if (f.__instrumented__) { return new f(...xs) }\n    return new f(...xs.map(force))\n  },\n  has: function (o, k) { return k in force(o) },\n  get: function (o, k, n) { return force(o)[force(k)] },\n  set: function (o, k, v, n) { return force(o)[force(k)]=v },\n  delete: function (o, k, n) { return delete force(o)[force(k)] },\n  enumerate: function (o, n) {\n    var ks = []\n    for (k in force(o)) { ks.push(k) }\n    return ks\n  }\n}\n\n// (function () {\n//   var counter = 0\n//   // Work with binary && resolved once\n//   var p1 = delay(function () {\n//     counter++\n//     return 3\n//   })\n//   if (p1+p1 !== 6) { throw \"addition\" }\n//   if (counter !== 1) { throw \"counter\" }\n//   // Works with built-in functions \n//   var p2 = delay(function () { return {a:1} })\n//   if (JSON.stringify(p2) !== '{\"a\":1}')\n//     throw \"stringify\"\n// } ())\n";
window.masters.Identity = "\n// This master traps everything and forward it //\n\nexports.sandbox = window\n\nexports.options = {\n  ast:true,\n  loc:true,\n  range:true\n}\n\nexports.traps = {\n  primitive: function (x, n) { return x },\n  undefined: function (s, n) { return undefined },\n  object: function (x, n) { return x },\n  array: function (x, n) { return x },\n  arguments: function (x, n) { return x },\n  function: function (x, n) { return x },\n  regexp: function (p, f, n) { return RegExp(p, f) },\n  booleanize: function (x, n) { return x },\n  stringify: function (x, n) { return x },\n  catch: function (x, n) { return x },\n  unary: function (op, x, n) { return eval(op+\" x\") },\n  binary: function (op,  x1, x2, n) { return eval(\"x1 \"+op+\" x2\") },\n  apply: function (f, o, xs, n) { return f.apply(o, xs) },\n  new: function (f, xs, n) { return new f(...xs) },\n  has: function (o, k) { return k in o },\n  get: function (o, k, n) { return o[k] },\n  set: function (o, k, v, n) { return o[k]=v },\n  delete: function (o, k, n) { return delete o[k] },\n  enumerate: function (o, n) {\n    var ks = []\n    for (k in o) { ks.push(k) }\n    return ks\n  }\n}\n";
window.masters.Sandbox = "\n// A very strict sandbox that only whitelist Math and JSON //\n\nexports.sandbox = {\n  Math:Math,\n  JSON:JSON\n}\n\n// aran.sandbox = window\n// window.aran.sandbox = window\n// function f () { this.alert(\"BOUM\") }\n// f()\n";
window.masters.Taint = "\nfunction id (x) { return x }\n\nfunction isprimitive (x) {\n  return (x===null)\n    || (x===undefined)\n    || (typeof x===\"boolean\")\n    || (typeof x===\"number\")\n    || (typeof x===\"string\")\n}\n\nfunction box (x) {\n  if (typeof x === \"boolean\") { return new Boolean(x) }\n  if (typeof x === \"number\") { return new Number(x) }\n  if (typeof x === \"string\") { return new String(x) }\n  return x\n}\n\n//////////////////\n// Taint values //\n//////////////////\n\nvar tainted = new WeakSet()\n\nfunction taint (x) {\n  if (x===null||x===undefined) { return x } // cannot taint null && undefined\n  if (isprimitive(x)) { x = box(x) }\n  else {\n    var copy = {}\n    for (var k in x) { copy[k] = taint(x[k]) }\n    x = copy\n  }\n  tainted.add(x)\n  return x\n}\n\nfunction istainted (x) {\n  if (tainted.has(x)) { return true }\n  if (!isprimitive(x)) { for (var k in x) { if (istainted(x[k])) { return true } } }\n  return false\n}\n\n//////////////////////////////////////////////////\n// Sandbox:                                     //\n//  1. Prevent tainted values to access IOs     //\n//  2. Propage taint on built-in function calls //\n//////////////////////////////////////////////////\n\n// Create taint values\nfunction source (fct) {\n  return function () {\n    return taint(fct.apply(this, arguments))\n  }\n}\n\n// Forward tainted values\nfunction river (fct) {\n  return function () {\n    var post = id\n    for (var i=0; i<arguments.length; i++) {\n      if (istainted(arguments[i])) { post = taint }\n    }\n    return post(fct.apply(this, arguments))\n  }\n}\n\n// Check no taint values sink in\nfunction sink (fct) {\n  return function () {\n    for (var i=0; i<arguments.length; i++) {\n      if (istainted(arguments[i])) { throw new Error(\"Tainted value into sink (argument \"+i+\")\") }\n    }\n    return fct.apply(this, arguments)\n  }\n}\n\nexports.sandbox = {\n  prompt: source(window.prompt.bind(window)),\n  alert: sink(window.alert.bind(window)),\n  eval: sink(window.eval),\n  JSON: {\n    parse: river(window.JSON.parse),\n    stringify: river(window.JSON.stringify)\n  }\n}\n\n///////////////////////////////////////////////////////////\n// Traps:                                                //\n//   1. Prevent tainted value to affect the control flow //\n//   2. Propagate taint on unary-binary operations       //\n///////////////////////////////////////////////////////////\n\nexports.traps = {\n  booleanize: function (x) {\n    if (istainted(x)) { throw new Error(\"Taint value flows in program conditional\") }\n    return x\n  },\n  stringify: function (x) {\n    if (istainted(x)) { throw new Error(\"Taint value flows in direct eval call\") }\n    return x\n  },\n  unary: function (op, x) {\n    if (istainted(x)) { return taint(eval(op+\" x\")) }\n    return eval(op+\" x\")\n  },\n  binary: function (op,  x1, x2) {\n    var post = id\n    if (istainted(x1)) { post=taint }\n    if (istainted(x2)) { post=taint }\n    return post(eval(\"x1 \"+op+\" x2\"))\n  }\n}\n\n/////////////\n// Example //\n/////////////\n\n// var x = prompt(\"Enter something evil!\");\n// var o = {a:\"Safe\"}\n// o.b = \"foo \"+x+\" bar\"\n// function f (arg) {\n//   alert(arg.a)\n//   alert(arg.b)\n// }\n// f(o)\n\n";
window.masters.TrackNullUndefined = "\n// This master tracks the origin of null and undefined values //\n\nfunction wrap (x, origin, varname) {\n  if (x === null || x === undefined) {\n    return {\n      __void__: true,\n      value: x,\n      origin: origin,\n      varname: varname\n    }\n  }\n  return x\n}\n\nfunction unwrap (x) { return x.__void__?x.value:x }\n\nfunction print (x) {\n  var start = x.origin.loc.start\n  var msg = x.value+\"@\"+start.line+\"-\"+start.column\n  if (x.varname) { msg = msg+\" (\"+x.varname+\")\" }\n  return msg\n}\n\nexports.options = {ast:true, loc:true}\n\nexports.traps = {\n  primitive: function (val, node) { return wrap(val, node) },\n  undefined: function (varname, node) { return wrap(undefined, node, varname) },\n  booleanize: function (val, node) { return unwrap(val) },\n  stringify: function (val, node) { return unwrap(val) },\n  unary: function (op, x, node) { return wrap(eval(op+\" unwrap(x)\"), node) },\n  binary: function (op, x, y, node) { return wrap(eval(\"unwrap(x) \"+op+\" unwrap(y)\"), node) },\n  get: function (obj, prop, node) {\n    prop = unwrap(prop)\n    if (obj.__void__) { throw new TypeError(\"Cannot read property \"+prop+\" of \"+print(obj)) }\n    return wrap(obj[prop], node)\n  },\n  set: function (obj, prop, val, node) {\n    prop = unwrap(prop)\n    if (obj.__void__) { throw new TypeError(\"Cannot set property \"+prop+\" of \"+print(obj)) }\n    return obj[prop] = val\n  },\n  delete: function (obj, prop, node) {\n    prop = unwrap(prop)\n    if (obj.__void__) { throw new TypeError(\"Connot delete property \"+prop+\" of \"+print(obj)) }\n    return delete obj[prop]\n  },\n  enumerate: function (obj, node) {\n    var keys = []\n    for (var key in unwrap(obj)) { keys.push(key) }\n    return keys\n  },\n  catch: function (err, node) { return wrap(err, node) },\n  function: function (fct, node) {\n    fct.__instrumented__ = true\n    return fct\n  },\n  apply: function (fct, th, args, node) {\n    if (fct.__void__) { throw new TypeError(print(fct)+\" is not a function\") }\n    if (fct.__instrumented__) { return fct.apply(th, args) }\n    return wrap(fct.apply(unwrap(th), args.map(unwrap)), node)\n  },\n  new: function (fct, args, node) {\n    if (fct.__void__) { throw new TypeError(print(fct)+\" is not a constructor\") }\n    if (fct.__instrumented__) {\n      var o = Object.create(fct.prototype)\n      var res = fct.apply(o, args)\n      if (res.__void__) { return o }\n      if (typeof res !== \"object\") { return o }\n      return res\n    }\n    return wrap(new fct(...args.map(unwrap)), node)\n  }\n}\n\n// (function () {\n//   x = {a:y}\n//   y = \"foo\"\n//   function f (z) { z.a() }\n//   f(x)\n//   var x, y\n// } ());\n";
window.masters.Logger = "\n// This master traps everything, log it and forward it // \n\nexports.sandbox = new Proxy(window, {\n  has: function (s, p) { return (console.log(\"GlobalHas \"+p), p in s) },\n  get: function (s, p) { return (console.log(\"GlobalGet \"+p), s[p]) },\n  set: function (s, p, v) { return (console.log(\"GlobalSet \"+p), s[p]=v) },\n  deleteProperty: function (s, p) { return (console.log(\"GlobalDel \"+p), delete s[p]) }\n})\n\nexports.options = {ast:true, loc:true}\n\nexports.traps = {\n  primitive: function (x, n) { return log(\"primitive\", n, x) },\n  undefined: function (s, n) { return (log(\"undefined\", n, s), undefined) },\n  object: function (x, n) { return log(\"object\", n, x) },\n  array: function (x, n) { return log(\"array\", n, x) },\n  arguments: function (x, n) { return log(\"arguments\", n, x) },\n  function: function (x, n) { return log(\"function\", n, x) },\n  regexp: function (p, f, n) { return (log(\"regexp\", n, p , f), RegExp(p, f)) },\n  booleanize: function (x, n) { return log(\"booleanize\", n, x) },\n  stringify: function (x, n) { return log(\"stringify\", n, x) },\n  catch: function (x, n) { return log(\"catch\", n, x) },\n  unary: function (op, x, n) { return (log(\"unary\", n, op, x), eval(op+\" x\")) },\n  binary: function (op, x1, x2, n) { return (log(\"binary\", n, op, x1, x2), eval(\"x1 \"+op+\" x2\")) },\n  apply: function (f, o, xs, n) { return (log(\"apply\", n, f, o, xs), f.apply(o, xs)) },\n  new: function (f, xs, n) { return (log(\"new\", n, f, xs), new f(...xs)) },\n  has: function (o, k) { return (log(\"has\", undefined, o, k), k in o) },\n  get: function (o, k, n) { return (log(\"get\", n, o, k), o[k]) },\n  set: function (o, k, v, n) { return (log(\"set\", n, o, k, v), o[k]=v) },\n  delete: function (o, k, n) { return (log(\"delete\", n, o, k), delete o[k]) },\n  enumerate: function (o, n) {\n    log(\"enumerate\", n, o)\n    var ks = []\n    for (k in o) { ks.push(k) }\n    return ks\n  }\n}\n\nfunction log (trap, n, x) {\n  var msg = trap\n  if (n) { msg += \"@\"+n.loc.start.line+\"-\"+n.loc.start.column+\":\"+n.type }\n  for (var i=2; i<arguments.length; i++) {\n    if (typeof arguments[i] === \"function\") {\n      msg += \" [function \"+arguments[i].name+\"]\"\n    } else {\n      msg += \" \"+String(arguments[i])\n    }\n  }\n  console.log(msg)\n  return x\n}\n";
